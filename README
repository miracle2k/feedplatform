FeedPlatform
============

FeedPlatform implements the core functionality of a feed aggregator. It is
supposed to be lightweight, reusable and extremely flexible, mainly intended
for integration with other applications.

It consists of:

    - A database, holding feeds (as defined by the user) and items (as
      managed by the library, gathered by parsing the feeds).

    - A daemonizable script to regularily check the feeds for changes, and
      update the database accordingly.

Not provided are facilities to actually access the database from the
outside - you are expected to have your own interface to the data (e.g. an
ORM in your application).

In it's simpliest form (the default state, if used without configuration),
the **feed** database table will merely consist of one column storing the
URL (besides the primary id column), and the **item** table's only field
stores the guid that makes it identifiable.

Using the hook and addin infrastructure, you are able to build upon this a
full-blown feed aggregator that stores metadata, handles feed images, claim
codes, enclosures and parses feeds in a prioritized, distributed manner -
often with just a few lines in a configuration file.

Adding FeedPlatform to your application usually works like this:

    1. Define tables in your application to hold the aggregator data (feeds,
       items, etc). If those already exist, good for you - FeedPlatform will
       be happy to adapt to your schema.
    2. Make FeedPlatform understand the schema you are using via a config
       file.

If that sounds to compliated, you can consider skipping step 1 and using
the default database schema. In that case, step 2 will consist of making
your own application aware of that default schema.


Installation
------------

Simply add FeedPlatform to your path, and make sure the following
dependencies are available:

    * Storm ORM (https://storm.canonical.com/)
    * Universal Feed Parser (http://www.feedparser.org/)
    * Pyro (http://pyro.sourceforge.net/)

To use the Django integration, obviously the Django framework is
required:

    http://www.djangoproject.com/

To run the tests, you will need nose:

    http://www.somethingaboutorange.com/mrl/projects/nose/


Tutorial
--------

At the core of your interaction with the FeedPlatform, development-wise,
is the configuration file. You define which configuration file to use via
the ``FEEDPLATFORM_CONFIG`` environment variable, before you load and use
the library - very similar to how the Django settings mechanism works.

If you want to use FeedPlatform multiple times on the same server, e.g.
with different databases, projects etc., simply make sure the correct
config file is set each time - in the simpliest case by manipulating
``os.environ``.

FeedPlatform absolutely requires a configuration to run, since it depends
on a database. However, it will not enforce that restriction unless
actually necessary, so you will be able to do certain things without one.

For starters, let's see what database schema we operate with per default,
unmodified by a config file::

    $ feedplatform.py models
    Feed
        id: Int
        url: Unicode
    Item
        feed_id: Int
        guid: Unicode

.. note:: The distutils setup will have placed the ``feedplatform``
   command line tool on your path; if that is not the case, you can find
   it inside the ``feedplatform.bin`` namespace.

Obviously, this is not yet very useful; at the very least, we want to
store some data, like the title and description of each feed, and the same
for each item.

So, let's create a config file. You can be put anywhere you like, as long
as you point the ``FEEDPLATFORM_CONFIG`` environment variable to the
right place:

    FEEDPLATFORM_CONFIG = '/var/www/maypp/aggregator/config.py'

If you have *myapp* on your path, you can also say:

    FEEDPLATFORM_CONFIG_MODULE = 'maypp.aggregator.config'

Create this file, and put this in there:

{{{
MODELS = {
    'feed':[collect_data()],
    'item': [collect_item_data()],
}
}}}
# TODO: Replace with correct addin names and syntax

.. note:: In the future, you may use ``feedplatform new-config`` to
generate a new configuration file based on a easier to use template.

This will collect a default set of data, but you could specify this
further, e.g.

    collect_data("title", "description"])
    # TODO: Replace with correct addin names and syntax

Now let's see how our models have changed:

    $ set FEEDPLATFORM_CONFIG = '~/myconfig.py'
    $ feedplatform models
    # TODO: add actual output here

As you can see, both tables have a bunch of new fields.

# TODO: Give another example using the enclosures addin

# TODO: Explain running the daemon


Available addins
----------------

To be added.


Your own addins
~~~~~~~~~~~~~~~

To be added, but might look something like this:

    class store_enclosures(addins.base):
        def __init(force=False):
            from feedplatform import models
            models.AVAILABLE['enclosure'] = base_enclosure_fields
            self.log.debug("addin initialized")

        def get_columns(self):
            pass

        def on_some_hook():
            # will automatically be registered as a callback
            pass

        def configured(self):
            from feedplatform import db
            # e.g. monkey patch custom next method into FeedStore.


Integration with Django
-----------------------

There is a Django application in ``feedplatform.integration.django`` that
you can add to the ``INSTALLED_APPS`` setting of a Django project in
which you are using FeedPlatform.

The application expects you to have a ``FEEDPLATFORM_CONFIG`` option in
your Django settings module, removing the need for the environment
variable. It will then make the ``feedplatform.py`` command line tool
available as a Django management command:

    ./manage.py feedplatform help
    ./manage.py feedplatform models
    ./manage.py feedplatform run --daemonize


Configuration options
---------------------

DATABASE
~~~~~~~~

Default: *Not available*

A database connection string. This option is required.

Examples:

    - backend:database_name
    - backend://hostname/database_name
    - backend://hostname:port/database_name
    - backend://username:password@hostname/database_name
    - backend://hostname/database_name?option=value
    - backend://username@/database_name

ADDINS
~~~~~~

Default: ``()`` (Empty tuple)

List any number of addins to extend, customize and specifiy the
functionality you need.

Examples:

    from feedplatform.addins import *

    ADDINS = [
        addin1(),
        addin2(),
        another_addin(),
    ]

USER_AGENT
~~~~~~~~~~

Default: ``FeedPlatform Python Library``

Allows you to change the useragent string that is passed along to the
feedparser library. Used primarily for HTTP interactions, of course.

ENFORCE_URI_SCHEME
~~~~~~~~~~~~~~~~~~

Default: ``('http', 'https')``

Allows you to limit the supported URI schemes. The feedparser backend
supports a variety of access methods, including local filenames
and even string data, which would pose a security risk if you allow users
to add new feeds to your database without further checks.

You can set it to ``False`` to disable any restrictions completely.


Testing FeedPlatform
--------------------

Nose (http://www.somethingaboutorange.com/mrl/projects/nose/) is used as
a testrunner. Just do:

    $ nosetests ./feedplatform/tests

Writing tests
~~~~~~~~~~~~~

The vast majority of tests obviously involves looking at feeds one way
or another, often in multiple steps, e.g. "if an item was added to the
feed, will that be picked up"? Testing scenarios like this over and
over again can be very tedious, repetitive and error prone, so
FeedPlatform implements it's own little test architecture to streamline
that process.

Through a nose plugin, in addition to standard python test files we pick
up all files with an **.at** extension (aggregator test). Those files
define which feeds are involved in the test, how the feeds evolve during
the test, if at all, and also the Python test code itself.

A single feed looks like this (remember, multiple of those may be inside
the same test file:

    [guid_test.xml:3]
    <rss>
      <channel>
        <item>
          <title>Foo</title>
          <guid>http://example.org/posts/foo</guid>
        </item>
        {% >1 %}
        <item>
          <title>Bar</title>
          <guid>http://example.org/posts/bar</guid>
        </item>
        {% end %}
      </channel>
    </rss>

    def count():
        return feed.items.count()
    1>>>
    assert count() == 1
    2>>>
    assert count() == 2
    3>>>
    assert count() == 2

The above feed is called **guid_test.xml** (which is only relevant when
you want to interact with it from standard python tests). It has three
passes, which means it will be parsed three times during the lifetime of
the test.

Before each pass, the feed content is reevaluated, and may change based
on the {%%} tags. For example, in the above example, during pass 1, only
the first item will exist. Only in pass two and is the second available.

Finally, the last section, separated by an empty line, uses ordinary
Python to implement the actual test logic. You can write different test
code for each pass by prefixing it with **PASSNUM>>>** - everything
that follows until the next of those separators will be run for this
particular pass.

A number of variables will automatically be available to you, like
``feed`` for the object representing the current feed.

If your tests involve HTTPS headers, place them before the feed content,
separated by an empty line, just like a real HTTP transaction.


TODO:
-----
    - add one or more example projects
    - possibly add automatic model creation to Django integration, e.g.

            AbstractFeed, AbstractItem, AbstractEnclosure = feedplatform.django.generate_models()

            class Feed(AbstractFeed):
                pass

      or, automatically via a setting:

           settings.FEEDPLATFORM_AUTOGENERATE_MODELS = TRUE
           from feedplatform.integration.django import models
           models.Feed

    - explain and provide better tools to use custom model classes
    - automatic schema creation (generate create table statements)
    - let user configure if a feed failure should be logged as a warning
      or just an info (or an error?)