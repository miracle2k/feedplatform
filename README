FeedPlatform
============

FeedPlatform implements the core functionality of a feed aggregator. It is
supposed to be lightweight, reusable and extremely flexible, mainly intended
for integration with other applications.

It consists of:

    - A database, holding feeds (as defined by the user) and items (as
      managed by the library, gathered by parsing the feeds).

    - A daemonizable script to regularily check the feeds for changes, and
      update the database accordingly.

Not provided are facilities to actually access the database from the
outside - you are expected to have your own interface to the data (e.g. an
ORM in your application).

In it's simpliest form (the default state, if used without configuration),
the **feed** database table will merely consist of one column storing the
URL (besides the primary id column), and the **item** table's only field
stores the guid that makes it identifiable.

Using the hook and addin infrastructure, you are able to build upon this a
full-blown feed aggregator that stores metadata, handles feed images, claim
codes, enclosures and parses feeds in a prioritized, distributed manner -
often with just a few lines in a configuration file.

Adding FeedPlatform to your application usually works like this:

    1. Define tables in your application to hold the aggregator data (feeds,
       items, etc). If those already exist, good for you - FeedPlatform will
       be happy to adapt to your schema.
    2. Make FeedPlatform understand the schema you are using via a config
       file.

If that sounds to compliated, you can consider skipping step 1 and using
the default database schema. In that case, step 2 will consist of making
your own application aware of that default schema.


Installation
------------

Simply add FeedPlatform to your path, and make sure the following
dependencies are available:

    * Storm ORM (https://storm.canonical.com/)
    * Universal Feed Parser (http://www.feedparser.org/)
    * Pyro (http://pyro.sourceforge.net/)

To use the Django integration, obviously the Django framework is
required:

    http://www.djangoproject.com/

To run the tests, you will need nose:

    http://www.somethingaboutorange.com/mrl/projects/nose/


Tutorial
--------

At the core of your interaction with the FeedPlatform, development-wise,
is the configuration file. You define which configuration file to use via
the ``FEEDPLATFORM_CONFIG`` environment variable, before you load and use
the library - very similar to how the Django settings mechanism works.

If you want to use FeedPlatform multiple times on the same server, e.g.
with different databases, projects etc., simply make sure the correct
config file is set each time - in the simpliest case by manipulating
``os.environ``.

FeedPlatform absolutely requires a configuration to run, since it depends
on a database. However, it will not enforce that restriction unless
actually necessary, so you will be able to do certain things without one.

For starters, let's see what database schema we operate with per default,
unmodified by a config file::

    $ feedplatform.py models
    Feed
        id: Int
        url: Unicode
    Item
        feed_id: Int
        guid: Unicode

.. note:: The distutils setup will have placed the ``feedplatform``
   command line tool on your path; if that is not the case, you can find
   it inside the ``feedplatform.bin`` namespace.

Obviously, this is not yet very useful; at the very least, we want to
store some data, like the title and description of each feed, and the same
for each item.

So, let's create a config file. You can be put anywhere you like, as long
as you point the ``FEEDPLATFORM_CONFIG`` environment variable to the
right place:

    FEEDPLATFORM_CONFIG = '/var/www/maypp/aggregator/config.py'

If you have *myapp* on your path, you can also say:

    FEEDPLATFORM_CONFIG_MODULE = 'maypp.aggregator.config'

Create this file, and put this in there:

{{{
MODELS = {
    'feed':[collect_data()],
    'item': [collect_item_data()],
}
}}}
# TODO: Replace with correct addin names and syntax

.. note:: In the future, you may use ``feedplatform new-config`` to
generate a new configuration file based on a easier to use template.

This will collect a default set of data, but you could specify this
further, e.g.

    collect_data("title", "description"])
    # TODO: Replace with correct addin names and syntax

Now let's see how our models have changed:

    $ set FEEDPLATFORM_CONFIG = '~/myconfig.py'
    $ feedplatform models
    # TODO: add actual output here

As you can see, both tables have a bunch of new fields.

# TODO: Give another example using the enclosures addin

# TODO: Explain running the daemon


Available addins
----------------

To be added.


Your own addins
~~~~~~~~~~~~~~~

To be added, but might look something like this:

    class store_enclosures(addins.base):
        def __init(force=False):
            from feedplatform import models
            models.AVAILABLE['enclosure'] = base_enclosure_fields
            self.log.debug("addin initialized")

        def get_columns(self):
            pass

        def on_some_hook():
            # will automatically be registered as a callback
            pass

        def configured(self):
            from feedplatform import db
            # e.g. monkey patch custom next method into FeedStore.


Integration with Django
-----------------------

There is a Django application in ``feedplatform.integration.django`` that
you can add to the ``INSTALLED_APPS`` setting of a Django project in
which you are using FeedPlatform.

The application expects you to have a ``FEEDPLATFORM_CONFIG`` option in
your Django settings module, removing the need for the environment
variable. It will then make the ``feedplatform.py`` command line tool
available as a Django management command:

    ./manage.py feedplatform help
    ./manage.py feedplatform models
    ./manage.py feedplatform run --daemonize


Configuration options
---------------------

DATABASE
~~~~~~~~

Default: *Not available*

A database connection string. This option is required.

Examples:

    - backend:database_name
    - backend://hostname/database_name
    - backend://hostname:port/database_name
    - backend://username:password@hostname/database_name
    - backend://hostname/database_name?option=value
    - backend://username@/database_name

ADDINS
~~~~~~

Default: ``()`` (Empty tuple)

List any number of addins to extend, customize and specifiy the
functionality you need.

Examples:

    from feedplatform.addins import *

    ADDINS = [
        addin1(),
        addin2(),
        another_addin(),
    ]

USER_AGENT
~~~~~~~~~~

Default: ``FeedPlatform Python Library``

Allows you to change the useragent string that is passed along to the
feedparser library. Used primarily for HTTP interactions, of course.

ENFORCE_URI_SCHEME
~~~~~~~~~~~~~~~~~~

Default: ``('http', 'https')``

Allows you to limit the supported URI schemes. The feedparser backend
supports a variety of access methods, including local filenames
and even string data, which would pose a security risk if you allow users
to add new feeds to your database without further checks.

You can set it to ``False`` to disable any restrictions completely.

URLLIB2_HANDLERS
~~~~~~~~~~~~~~~~

Default: ``()`` (Empty tuple)

Custom handlers that will be passed to urllib2 when fetching feeds. This,
among other things, allows you to add support for new protocols. Note that
you then might need to update ENFORCE_URI_SCHEME as well.


Testing FeedPlatform
--------------------

Nose (http://www.somethingaboutorange.com/mrl/projects/nose/) is used as
a testrunner. Just do:

    $ nosetests ./feedplatform/tests

Writing tests
~~~~~~~~~~~~~

The vast majority of tests obviously involves looking at feeds one way
or another, often in multiple steps, e.g. "if an item was added to the
feed, will that be picked up"? Testing scenarios like this over and
over again can be very tedious and error prone. To streamline that
process, a simple framework is provided that tries to link the required
"feed evolutions" to the testcase implementations.

Such a test case will thus involve multiple "passes", i.e. the feed is
parsed multiple times, and every time the test code needs to make sure
that the necessary conditions are met. Using feed evolutions, a test
module might look like this:

    from tests import feedev

    class GuidTest(feedev.Feed):
        content = \"""
            <item guid="abcdefg" />
            {% 2 %}
            <item guid="ehijklm" />
            {% end %}
        \"""

        def pass1(feed):
            assert feed.items.count() == 1

        def pass2(feed):
            assert feed.items.count() == 2

    def test():
        feedev.testmod()

The module contains only one nose testcase, which simply instructs the
our framework to test the current module. It will then, for the number
of passes requested, update each feed (all ``feedev.Feed`` subclasses)
through the FeedPlatform libraries (which is what we are testing)! The
number of passes is determined by the maximum X of all the ``passX``
test methods that are defined on any of the feeds.

On each pass, a  feed's content is reevaluated, and may change based on
{% %}-tags in the template. In the above example, during pass 1 only
the first item will exist. In pass two (and above) the second is
available as well.

Finally, everytime a feed was updated, the framework will call the
appropriate ``passX`` method, if it exists. This is the place were you
should put your actual test code. Note that those are static methods -
they do not take a ``self`` argument.


TODO:
-----
    - add one or more example projects
    - possibly add automatic model creation to Django integration, e.g.

            AbstractFeed, AbstractItem, AbstractEnclosure = feedplatform.django.generate_models()

            class Feed(AbstractFeed):
                pass

      or, automatically via a setting:

           settings.FEEDPLATFORM_AUTOGENERATE_MODELS = TRUE
           from feedplatform.integration.django import models
           models.Feed

    - explain and provide better tools to use custom model classes
    - automatic schema creation (generate create table statements)
    - let user configure if a feed failure should be logged as a warning
      or just an info (or an error?)